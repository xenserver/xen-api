#!/usr/bin/env python

"""
Copyright (C) 2006-2009 Citrix Systems Inc.
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation; version 2.1 only. with the special
exception on linking described in file LICENSE.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
"""

import sys
import os
import subprocess
import time
import re
from optparse import OptionParser
import XenAPI
import signal

pool_conf = '@ETCDIR@/pool.conf'
interface_reconfigure = "@LIBEXECDIR@/interface-reconfigure"
inventory_file = '@INVENTORY@'
management_conf = '/etc/firstboot.d/data/management.conf'
network_reset = '/tmp/network-reset'
network_scripts_path = '/etc/sysconfig/network-scripts'

FNULL = open(os.devnull, 'w')

def read_dict_file(fname):
	f = open(fname, 'r')
	d = {}
	for l in f.readlines():
		kv = l.split('=')
		d[kv[0]] = kv[1][1:-2]
	return d

def read_inventory():
	return read_dict_file(inventory_file)

def read_management_conf():
	return read_dict_file(management_conf)

def write_inventory(inventory):
	f = open(inventory_file, 'w')
	for k in inventory:
		f.write(k + "='" + inventory[k] + "'\n")
	f.flush()
	os.fsync(f.fileno())
	f.close()

def valid_vlan(vlan):
	if not re.match('^\d+$', vlan):
		return False
	if int(vlan)<0 or int(vlan)>4094:
		return False
	return True

if __name__ == "__main__":
	parser = OptionParser()
	parser.add_option("-m", "--master", help="Master's address", dest="address", default=None)
	parser.add_option("--device", help="Device name of new management interface", dest="device", default=None)
	parser.add_option("--mode", help='IP configuration mode for new management interface: "dhcp" or "static" (default is dhcp)', dest="mode", default="dhcp")
	parser.add_option("--novlan", help="no vlan is used for new management interface", dest="novlan", action="store_const", const=True, default=False)
	parser.add_option("--vlan", help="vlanID for new management interface to be on vlan network", dest="vlan", default=None)
	parser.add_option("--ip", help="IP address for new management interface", dest="ip", default='')
	parser.add_option("--netmask", help="Netmask for new management interface", dest="netmask", default='')
	parser.add_option("--gateway", help="Gateway for new management interface", dest="gateway", default='')
	parser.add_option("--dns", help="DNS server for new management interface", dest="dns", default='')
	(options, args) = parser.parse_args()
	
	# Determine pool role
	isPool = False
	network_ref = None
	try:
		f = open(pool_conf, 'r')
		try:
			l = f.readline()
			ls = l.split(':')
			if ls[0].strip() == 'master':
				master = True
				address = 'localhost'
			else:
				master = False
				if options.address == None:
					address = ls[1].strip()
				else:
					address = options.address
			isPool = True
		finally:
			f.close()
	except:
		pass
	
	# Get the management device from the firstboot data if not specified by the user
	if options.device == None:
		try:
			conf = read_management_conf()
			device = conf['LABEL']
		except:
			print "Could not figure out which interface should become the management interface. \
				Please specify one using the --device option."
			sys.exit(1)
	else:
		device = options.device

	# Get the VLAN if provided in the firstboot data and not specified by the user
	vlan = None
	if options.vlan:
		if options.novlan:
			parser.error('"--vlan <vlanId>" and "--novlan" should not be used together')
			sys.exit(1)
		if not valid_vlan(options.vlan):
			print "VLAN tag you gave was invalid, It must be between 0 and 4094"
			sys.exit(1)
		vlan = options.vlan
	elif not options.novlan:
		try:
			conf = read_management_conf()
			vlan = conf['VLAN']
		except KeyError:
			pass

	# Determine IP configuration for management interface
	options.mode = options.mode.lower()
	if options.mode not in ["dhcp", "static"]:
		parser.error('mode should be either "dhcp" or "static"')
		sys.exit(1)
		
	if options.mode == 'static' and (options.ip == '' or options.netmask == ''):
		parser.error("if static IP mode is selected, an IP address and netmask need to be specified")
		sys.exit(1)
	
	# Warn user
	if not os.access('/tmp/fist_network_reset_no_warning', os.F_OK):
		configuration = []
		configuration.append("Management interface:   " + device)
		configuration.append("IP configuration mode:  " + options.mode)
		if vlan != None:
			configuration.append("Vlan:                   " + vlan)
		if options.mode == "static":
			configuration.append("IP address:             " + options.ip)
			configuration.append("Netmask:                " + options.netmask)
		if options.gateway != '':
			configuration.append("Gateway:                " + options.gateway)
		if options.dns != '':
			configuration.append("DNS server(s):          " + options.dns)
		if isPool and master == False:
			configuration.append("Pool master's address:  " + address)
		warning = """----------------------------------------------------------------------
!! WARNING !!

This command will reboot the host and reset its network configuration.
Any running VMs will be forcefully shutdown.

Before completing this command:
- Where possible, cleanly shutdown all VMs running on this host.
- Disable HA if this host is part of a resource pool with HA enabled.
----------------------------------------------------------------------

Your network will be re-configured as follows:\n\n"""
		confirmation = """\n\nIf you want to change any of the above settings, type 'no' and re-run
the command with appropriate arguments (use --help for a list of options).

Type 'yes' to continue.
Type 'no' to cancel.
"""
		res = raw_input(warning + '\n'.join(configuration) + confirmation)
		if res <> 'yes':
			sys.exit(1)
	
	# Update master's IP, if needed and given
	if isPool and master == False and options.address != None:
		print "Setting master's ip (" + address + ")..."
		try:
			f = open(pool_conf, 'w')
			f.write('slave:' + address)
		finally:
			f.flush()
			os.fsync(f.fileno())
			f.close()

	# Construct bridge name for management interface based on convention
	if device[:3] == 'eth':
		bridge = 'xenbr' + device[3:]
	elif not vlan:
		bridge = 'br' + device
	else:
		print "device must be eth*, when using vlan."
		sys.exit(1)

	# Fetch bridge name for management interface if host is a slave and using vlan
	if isPool and master == False and vlan != None:
		print "Checking pool master reachability..."
		def getBridgeNameViaXenAPI():
			session = XenAPI.xapi_local()
			session.login_with_password("", "")
			pool_ref = session.xenapi.pool.get_all()[0]
			master_ref = session.xenapi.pool.get_master(pool_ref)
			management_pif_ref = session.xenapi.host.get_management_interface(master_ref)
			vlan_xapi = session.xenapi.PIF.get_VLAN(management_pif_ref)
			if vlan_xapi != vlan:
				print "ERROR: vlan tag for management interface on slave should match with master."
				print "INFO: master has management on VLAN %s, slave is asked to bring management on VLAN %s." % (vlan_xapi, vlan)
				sys.exit(1)
			network_ref = session.xenapi.PIF.get_network(management_pif_ref)
			return session.xenapi.network.get_bridge(network_ref)

		# Start xapi in case it might be not running
		subprocess.call(['service', 'xapi', 'start'], stdout=FNULL, stderr=subprocess.STDOUT)

		# Xapi calls might never return if master is not reachable. using 
		# Signal module to raise alarm on timeout.
		def handler(signum, frame):
			raise Exception("Timed Out")
		signal.signal(signal.SIGALRM, handler)

		attempt = 1
		while attempt <= 2:
			try:
				signal.alarm(30)
				bridge = getBridgeNameViaXenAPI()
				signal.alarm(0)
				print "Success, continuing with emergency network reset"
				break
			except Exception:
				signal.alarm(0)
				time.sleep(5)
				attempt += 1
		if attempt > 2:
			print "Pool master is currently not reachable."
			print "Checking pool master reachability with new values..."
			ifcfgName = "%s/ifcfg-%s.%s" % (network_scripts_path, device, vlan)
			ifcfgData = """VLAN=yes
DEVICE=%s.%s
BOOTPROTO=%s
ONBOOT=no""" % (device, vlan, options.mode)
			if options.mode == 'static':
				ifcfgData += """
IPADDR=%s
NETMASK=%s""" % (options.ip, options.netmask)
			try:
				# Create new interface and bring IP on it.
				with open(ifcfgName, 'w') as f:
					f.write(ifcfgData+"\n")
				subprocess.call(['ifup', '%s.%s' % (device, vlan)], stdout=FNULL, stderr=subprocess.STDOUT)

				# Attempt fetching bridge
				while attempt <= 10:
					try:
						signal.alarm(30)
						bridge = getBridgeNameViaXenAPI()
						signal.alarm(0)
						break
					except Exception:
						signal.alarm(0)
						time.sleep(5)
						attempt += 1
				if attempt > 10:
					print "Failed to reach master with new config. exiting..."
					sys.exit(1)
				print "Synced with master, continuing with emergency network reset."
			finally:
				try:
					subprocess.call(['ifdown', '%s.%s' % (device, vlan)], stdout=FNULL, stderr=subprocess.STDOUT)
				except:
					pass
				if os.path.exists(ifcfgName):
					os.remove(ifcfgName)

	# Ensure xapi is not running
	print "Stopping xapi..."
	os.system('service xapi stop >/dev/null 2>/dev/null')

	# Reconfigure new management interface
	print "Reconfiguring " + device + "..."
	if os.access('/tmp/do-not-use-networkd', os.F_OK):
		if_args = ' --force ' + bridge + ' rewrite --mac=x --device=' + device + ' --mode=' + options.mode
		if options.mode == 'static':
			if_args += ' --ip=' + options.ip + ' --netmask=' + options.netmask
			if options.gateway != '':
				if_args += ' --gateway=' + options.gateway
		os.system(interface_reconfigure + if_args + ' >/dev/null 2>/dev/null')
	else:
		os.system('service xcp-networkd stop >/dev/null 2>/dev/null')
		try: os.remove('/var/lib/xcp/networkd.db')
		except: pass

	# Update interfaces in inventory file
	print 'Updating inventory file...'
	inventory = read_inventory()
	inventory['MANAGEMENT_INTERFACE'] = bridge
	inventory['CURRENT_INTERFACES'] = ''
	write_inventory(inventory)

	# Rewrite firstboot management.conf file, which will be picked it by xcp-networkd on restart (if used)
	try:
		f = file(management_conf, 'w')
		f.write("LABEL='" + device + "'\n")
		f.write("MODE='" + options.mode + "'\n")
		if vlan != None:
			f.write("VLAN='" + vlan + "'\n")
		if options.mode == 'static':
			f.write("IP='" + options.ip + "'\n")
			f.write("NETMASK='" + options.netmask + "'\n")
			if options.gateway != '':
				f.write("GATEWAY='" + options.gateway + "'\n")
			if options.dns != '':
				f.write("DNS='" + options.dns + "'\n")
	finally:
		f.flush()
		os.fsync(f.fileno())
		f.close()

	# Write trigger file for XAPI to continue the network reset on startup
	try:
		f = file(network_reset, 'w')
		f.write('DEVICE=' + device + '\n')
		f.write('MODE=' + options.mode + '\n')
		if vlan != None:
			f.write('VLAN=' + vlan + '\n')
		if options.mode == 'static':
			f.write('IP=' + options.ip + '\n')
			f.write('NETMASK=' + options.netmask + '\n')
			if options.gateway != '':
				f.write('GATEWAY=' + options.gateway + '\n')
			if options.dns != '':
				f.write('DNS=' + options.dns + '\n')
	finally:
		f.flush()
		os.fsync(f.fileno())
		f.close()

	# Reset the domain 0 network interface naming configuration
	# back to a fresh-install state for the currently-installed
	# hardware.
	os.system("/etc/sysconfig/network-scripts/interface-rename.py --reset-to-install")

	# Reboot
	os.system("mount -o remount,rw / && reboot -f")

